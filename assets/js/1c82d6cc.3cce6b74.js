"use strict";(self.webpackChunkme=self.webpackChunkme||[]).push([[3319],{3905:function(e,r,n){n.d(r,{Zo:function(){return u},kt:function(){return h}});var t=n(7294);function a(e,r,n){return r in e?Object.defineProperty(e,r,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[r]=n,e}function i(e,r){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);r&&(t=t.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),n.push.apply(n,t)}return n}function o(e){for(var r=1;r<arguments.length;r++){var n=null!=arguments[r]?arguments[r]:{};r%2?i(Object(n),!0).forEach((function(r){a(e,r,n[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(n,r))}))}return e}function c(e,r){if(null==e)return{};var n,t,a=function(e,r){if(null==e)return{};var n,t,a={},i=Object.keys(e);for(t=0;t<i.length;t++)n=i[t],r.indexOf(n)>=0||(a[n]=e[n]);return a}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(t=0;t<i.length;t++)n=i[t],r.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=t.createContext({}),l=function(e){var r=t.useContext(s),n=r;return e&&(n="function"==typeof e?e(r):o(o({},r),e)),n},u=function(e){var r=l(e.components);return t.createElement(s.Provider,{value:r},e.children)},d={inlineCode:"code",wrapper:function(e){var r=e.children;return t.createElement(t.Fragment,{},r)}},p=t.forwardRef((function(e,r){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,u=c(e,["components","mdxType","originalType","parentName"]),p=l(n),h=a,m=p["".concat(s,".").concat(h)]||p[h]||d[h]||i;return n?t.createElement(m,o(o({ref:r},u),{},{components:n})):t.createElement(m,o({ref:r},u))}));function h(e,r){var n=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=p;var c={};for(var s in r)hasOwnProperty.call(r,s)&&(c[s]=r[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var l=2;l<i;l++)o[l]=n[l];return t.createElement.apply(null,o)}return t.createElement.apply(null,n)}p.displayName="MDXCreateElement"},6730:function(e,r,n){n.r(r),n.d(r,{assets:function(){return u},contentTitle:function(){return s},default:function(){return h},frontMatter:function(){return c},metadata:function(){return l},toc:function(){return d}});var t=n(7462),a=n(3366),i=(n(7294),n(3905)),o=["components"],c={title:"Binary Search",sidebar_position:2},s="Binary Search",l={unversionedId:"algorithm/Binary Search-exQSM4GIj",id:"algorithm/Binary Search-exQSM4GIj",title:"Binary Search",description:"The idea is to use binary search which is a Divide and Conquer algorithm. Like all divide-and-conquer algorithms, binary search first divides a large array into two smaller subarrays and then recursively (or iteratively) operate the subarrays. But instead of working on both subarrays, it discards one subarray and continues on the second subarray. This decision of discarding one subarray is made in just one comparison.",source:"@site/docs/algorithm/20220618-Binary Search-exQSM4GIj.md",sourceDirName:"algorithm",slug:"/algorithm/Binary Search-exQSM4GIj",permalink:"/docs/algorithm/Binary Search-exQSM4GIj",draft:!1,editUrl:"https://github.com/iamrahultanwar/me/tree/master/docs/algorithm/20220618-Binary Search-exQSM4GIj.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Binary Search",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Binary Search Tree",permalink:"/docs/algorithm/Binary Search Tree-PAnNjwSst"},next:{title:"Breadth-First Search",permalink:"/docs/algorithm/Breadth First Search-9XOs5wLb3"}},u={},d=[{value:"Working of Binary Search",id:"working-of-binary-search",level:2},{value:"Code Implementation",id:"code-implementation",level:2}],p={toc:d};function h(e){var r=e.components,c=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,t.Z)({},p,c,{components:r,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"binary-search"},"Binary Search"),(0,i.kt)("p",null,"The idea is to use binary search which is a Divide and Conquer algorithm. Like all divide-and-conquer algorithms, binary search first divides a large array into two smaller subarrays and then recursively (or iteratively) operate the subarrays. But instead of working on both subarrays, it discards one subarray and continues on the second subarray. This decision of discarding one subarray is made in just one comparison."),(0,i.kt)("h2",{id:"working-of-binary-search"},"Working of Binary Search"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"clipboard.png",src:n(107).Z,width:"438",height:"323"}),"\n",(0,i.kt)("img",{alt:"clipboard.png",src:n(2380).Z,width:"377",height:"334"}),"\n",(0,i.kt)("img",{alt:"clipboard.png",src:n(887).Z,width:"448",height:"339"})),(0,i.kt)("h2",{id:"code-implementation"},"Code Implementation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\nfunc BinarySearch(arr []int, k int) (bool, int) {\n    low := 0\n    high := len(arr) - 1\n    for low <= high {\n        median := (low + high) / 2\n        if arr[median] < k {\n            low = median + 1\n        } else {\n            high = median - 1\n        }\n    }\n\n    if low == len(arr) || arr[low] != k {\n        return false, -1\n    }\n\n    return true, low\n\n}\n\nfunc main() {\n\n    arr := []int{2, 3, 5, 7, 8, 10, 12, 15, 18, 20}\n    fmt.Println(BinarySearch(arr, 7))\n}\n\n')))}h.isMDXComponent=!0},887:function(e,r,n){r.Z=n.p+"assets/images/MuuuP0--7-clipboard-6159d8efa2b02ca8e41965e0e9244a0d.png"},107:function(e,r,n){r.Z=n.p+"assets/images/iI57Y9-_C-clipboard-ef4fb33acab4e7445862fba29de4870f.png"},2380:function(e,r,n){r.Z=n.p+"assets/images/l78O7pdpd-clipboard-6941c27a01cf0f76ab29750bc27b1edb.png"}}]);