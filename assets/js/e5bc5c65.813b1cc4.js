"use strict";(self.webpackChunkme=self.webpackChunkme||[]).push([[1085],{3905:function(e,r,t){t.d(r,{Zo:function(){return u},kt:function(){return p}});var n=t(7294);function a(e,r,t){return r in e?Object.defineProperty(e,r,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[r]=t,e}function i(e,r){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);r&&(n=n.filter((function(r){return Object.getOwnPropertyDescriptor(e,r).enumerable}))),t.push.apply(t,n)}return t}function o(e){for(var r=1;r<arguments.length;r++){var t=null!=arguments[r]?arguments[r]:{};r%2?i(Object(t),!0).forEach((function(r){a(e,r,t[r])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(r){Object.defineProperty(e,r,Object.getOwnPropertyDescriptor(t,r))}))}return e}function s(e,r){if(null==e)return{};var t,n,a=function(e,r){if(null==e)return{};var t,n,a={},i=Object.keys(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||(a[t]=e[t]);return a}(e,r);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)t=i[n],r.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=n.createContext({}),c=function(e){var r=n.useContext(l),t=r;return e&&(t="function"==typeof e?e(r):o(o({},r),e)),t},u=function(e){var r=c(e.components);return n.createElement(l.Provider,{value:r},e.children)},d={inlineCode:"code",wrapper:function(e){var r=e.children;return n.createElement(n.Fragment,{},r)}},f=n.forwardRef((function(e,r){var t=e.components,a=e.mdxType,i=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),f=c(t),p=a,h=f["".concat(l,".").concat(p)]||f[p]||d[p]||i;return t?n.createElement(h,o(o({ref:r},u),{},{components:t})):n.createElement(h,o({ref:r},u))}));function p(e,r){var t=arguments,a=r&&r.mdxType;if("string"==typeof e||a){var i=t.length,o=new Array(i);o[0]=f;var s={};for(var l in r)hasOwnProperty.call(r,l)&&(s[l]=r[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var c=2;c<i;c++)o[c]=t[c];return n.createElement.apply(null,o)}return n.createElement.apply(null,t)}f.displayName="MDXCreateElement"},9914:function(e,r,t){t.r(r),t.d(r,{assets:function(){return u},contentTitle:function(){return l},default:function(){return p},frontMatter:function(){return s},metadata:function(){return c},toc:function(){return d}});var n=t(7462),a=t(3366),i=(t(7294),t(3905)),o=["components"],s={title:"Binary Search Tree"},l="Binary Search Tree",c={unversionedId:"algorithm/Binary Search Tree-PAnNjwSst",id:"algorithm/Binary Search Tree-PAnNjwSst",title:"Binary Search Tree",description:"The idea is to use binary search which is a Divide and Conquer algorithm. Like all divide-and-conquer algorithms, binary search first divides a large array into two smaller subarrays and then recursively (or iteratively) operate the subarrays. But instead of working on both subarrays, it discards one subarray and continues on the second subarray. This decision of discarding one subarray is made in just one comparison.",source:"@site/docs/algorithm/20220618-Binary Search Tree-PAnNjwSst.md",sourceDirName:"algorithm",slug:"/algorithm/Binary Search Tree-PAnNjwSst",permalink:"/docs/algorithm/Binary Search Tree-PAnNjwSst",draft:!1,editUrl:"https://github.com/iamrahultanwar/me/tree/master/docs/algorithm/20220618-Binary Search Tree-PAnNjwSst.md",tags:[],version:"current",sidebarPosition:20220618,frontMatter:{title:"Binary Search Tree"},sidebar:"mainSidebar",previous:{title:"Algorithm",permalink:"/docs/algorithm/"},next:{title:"Binary Search",permalink:"/docs/algorithm/Binary Search-exQSM4GIj"}},u={},d=[{value:"BST Structure",id:"bst-structure",level:2},{value:"Reference",id:"reference",level:2}],f={toc:d};function p(e){var r=e.components,s=(0,a.Z)(e,o);return(0,i.kt)("wrapper",(0,n.Z)({},f,s,{components:r,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"binary-search-tree"},"Binary Search Tree"),(0,i.kt)("p",null,"The idea is to use binary search which is a Divide and Conquer algorithm. Like all divide-and-conquer algorithms, binary search first divides a large array into two smaller subarrays and then recursively (or iteratively) operate the subarrays. But instead of working on both subarrays, it discards one subarray and continues on the second subarray. This decision of discarding one subarray is made in just one comparison."),(0,i.kt)("h2",{id:"bst-structure"},"BST Structure"),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"clipboard.png",src:t(8694).Z,width:"1194",height:"614"})),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"clipboard.png",src:t(890).Z,width:"1460",height:"896"})),(0,i.kt)("h2",{id:"reference"},"Reference"),(0,i.kt)("iframe",{width:"950",height:"534",src:"https://www.youtube.com/embed/-oYitelECuQ",title:"Data Structures in Golang - Binary Search Tree",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-python"},"\nclass Node:\n    def __init__(self, key):\n        self.left = None\n        self.right = None\n        self.val = key\n\n    # Traverse preorder\n    def traversePreOrder(self):\n        print(self.val, end=' ')\n        if self.left:\n            self.left.traversePreOrder()\n        if self.right:\n            self.right.traversePreOrder()\n\n    # Traverse inorder\n    def traverseInOrder(self):\n        if self.left:\n            self.left.traverseInOrder()\n        print(self.val, end=' ')\n        if self.right:\n            self.right.traverseInOrder()\n\n    # Traverse postorder\n    def traversePostOrder(self):\n        if self.left:\n            self.left.traversePostOrder()\n        if self.right:\n            self.right.traversePostOrder()\n        print(self.val, end=' ')\n\n\n")))}p.isMDXComponent=!0},890:function(e,r,t){r.Z=t.p+"assets/images/23EfS6CPd-clipboard-dbb1063868ed1dc150e6570443a54bc7.png"},8694:function(e,r,t){r.Z=t.p+"assets/images/Hts2c9qa_-clipboard-4b8563ab9e29e40d63653d031fa246b9.png"}}]);