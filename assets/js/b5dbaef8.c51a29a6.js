"use strict";(self.webpackChunkme=self.webpackChunkme||[]).push([[8308],{3905:function(e,t,r){r.d(t,{Zo:function(){return c},kt:function(){return u}});var a=r(7294);function n(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function i(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function o(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?i(Object(r),!0).forEach((function(t){n(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):i(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function l(e,t){if(null==e)return{};var r,a,n=function(e,t){if(null==e)return{};var r,a,n={},i=Object.keys(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||(n[r]=e[r]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)r=i[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(n[r]=e[r])}return n}var s=a.createContext({}),h=function(e){var t=a.useContext(s),r=t;return e&&(r="function"==typeof e?e(t):o(o({},t),e)),r},c=function(e){var t=h(e.components);return a.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},p=a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,i=e.originalType,s=e.parentName,c=l(e,["components","mdxType","originalType","parentName"]),p=h(r),u=n,m=p["".concat(s,".").concat(u)]||p[u]||d[u]||i;return r?a.createElement(m,o(o({ref:t},c),{},{components:r})):a.createElement(m,o({ref:t},c))}));function u(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=r.length,o=new Array(i);o[0]=p;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:n,o[1]=l;for(var h=2;h<i;h++)o[h]=r[h];return a.createElement.apply(null,o)}return a.createElement.apply(null,r)}p.displayName="MDXCreateElement"},5693:function(e,t,r){r.r(t),r.d(t,{assets:function(){return c},contentTitle:function(){return s},default:function(){return u},frontMatter:function(){return l},metadata:function(){return h},toc:function(){return d}});var a=r(7462),n=r(3366),i=(r(7294),r(3905)),o=["components"],l={title:"Breadth-First Search",sidebar_position:3},s="Breadth First Search",h={unversionedId:"algorithm/Breadth First Search-9XOs5wLb3",id:"algorithm/Breadth First Search-9XOs5wLb3",title:"Breadth-First Search",description:"Breadth\u2013first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a \u2018search key\u2019) and explores the neighbor nodes first before moving to the next-level neighbors.",source:"@site/docs/algorithm/20220618-Breadth First Search-9XOs5wLb3.md",sourceDirName:"algorithm",slug:"/algorithm/Breadth First Search-9XOs5wLb3",permalink:"/docs/algorithm/Breadth First Search-9XOs5wLb3",draft:!1,editUrl:"https://github.com/iamrahultanwar/me/tree/master/docs/algorithm/20220618-Breadth First Search-9XOs5wLb3.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Breadth-First Search",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Binary Search",permalink:"/docs/algorithm/Binary Search-exQSM4GIj"},next:{title:"Depth First Search",permalink:"/docs/algorithm/Depth First Search-oDWIW4jHZ"}},c={},d=[{value:"Explanation",id:"explanation",level:2},{value:"BFS algorithm",id:"bfs-algorithm",level:2},{value:"BFS example",id:"bfs-example",level:2},{value:"BFS pseudocode",id:"bfs-pseudocode",level:2},{value:"BFS Algorithm Complexity",id:"bfs-algorithm-complexity",level:2},{value:"BFS Algorithm Applications",id:"bfs-algorithm-applications",level:2},{value:"Code Implementation",id:"code-implementation",level:2},{value:"Reference",id:"reference",level:2}],p={toc:d};function u(e){var t=e.components,l=(0,n.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},p,l,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"breadth-first-search"},"Breadth First Search"),(0,i.kt)("p",null,"Breadth\u2013first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph, sometimes referred to as a \u2018search key\u2019) and explores the neighbor nodes first before moving to the next-level neighbors."),(0,i.kt)("h2",{id:"explanation"},"Explanation"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://miro.medium.com/max/1000/0*tDMgFqo4ImTjMWdw.gif",alt:"clipboard.png"})),(0,i.kt)("p",null,"Breadth\u2013first search (BFS) is a graph traversal algorithm that explores vertices in the order of their distance from the source vertex, where distance is the minimum length of a path from the source vertex to the node as evident from the above example."),(0,i.kt)("p",null,"The time complexity of BFS traversal is O(V + E), where V and E are the total number of vertices and edges in the graph, respectively. Please note that O(E) may vary between O(1) and O(V2), depending on how dense the graph is."),(0,i.kt)("p",null,"Traversal means visiting all the nodes of a graph. Breadth First Traversal or Breadth First Search is a recursive algorithm for searching all the vertices of a graph or tree data structure."),(0,i.kt)("h2",{id:"bfs-algorithm"},"BFS algorithm"),(0,i.kt)("p",null,"A standard BFS implementation puts each vertex of the graph into one of two categories:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Visited"),(0,i.kt)("li",{parentName:"ol"},"Not Visited")),(0,i.kt)("p",null,"The purpose of the algorithm is to mark each vertex as visited while avoiding cycles."),(0,i.kt)("p",null,"The algorithm works as follows:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Start by putting any one of the graph's vertices at the back of a queue."),(0,i.kt)("li",{parentName:"ol"},"Take the front item of the queue and add it to the visited list."),(0,i.kt)("li",{parentName:"ol"},"Create a list of that vertex's adjacent nodes. Add the ones which aren't in the visited list to the back of the queue."),(0,i.kt)("li",{parentName:"ol"},"Keep repeating steps 2 and 3 until the queue is empty.")),(0,i.kt)("p",null,"The graph might have two different disconnected parts so to make sure that we cover every vertex, we can also run the BFS algorithm on every node"),(0,i.kt)("h2",{id:"bfs-example"},"BFS example"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Let's see how the Breadth First Search algorithm works with an example. We use an undirected graph with 5 vertices.")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"clipboard.png",src:r(5097).Z,width:"1460",height:"556"})),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Undirected graph with 5 vertices")),(0,i.kt)("p",null,"We start from vertex 0, the BFS algorithm starts by putting it in the Visited list and putting all its adjacent vertices in the stack."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"clipboard.png",src:r(118).Z,width:"1460",height:"556"})),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Visit start vertex and add its adjacent vertices to queue")),(0,i.kt)("p",null,"Next, we visit the element at the front of queue i.e. 1 and go to its adjacent nodes. Since 0 has already been visited, we visit 2 instead."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"clipboard.png",src:r(267).Z,width:"1460",height:"566"})),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Visit the first neighbour of start node 0, which is 1")),(0,i.kt)("p",null,"Vertex 2 has an unvisited adjacent vertex in 4, so we add that to the back of the queue and visit 3, which is at the front of the queue."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"clipboard.png",src:r(4673).Z,width:"1460",height:"566"})),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Visit 2 which was added to queue earlier to add its neighbours")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"clipboard.png",src:r(5001).Z,width:"1460",height:"566"})),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"4 remains in the queue")),(0,i.kt)("p",null,"Only 4 remains in the queue since the only adjacent node of 3 i.e. 0 is already visited. We visit it."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"clipboard.png",src:r(2568).Z,width:"1460",height:"566"})),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Visit last remaining item in the queue to check if it has unvisited neighbors")),(0,i.kt)("p",null,"Since the queue is empty, we have completed the Breadth First Traversal of the graph."),(0,i.kt)("h2",{id:"bfs-pseudocode"},"BFS pseudocode"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"create a queue Q\nmark v as visited and put v into Q\nwhile Q is non-empty\n    remove the head u of Q\n    mark and enqueue all (unvisited) neighbours of u\n")),(0,i.kt)("h2",{id:"bfs-algorithm-complexity"},"BFS Algorithm Complexity"),(0,i.kt)("p",null,"The time complexity of the BFS algorithm is represented in the form of ",(0,i.kt)("inlineCode",{parentName:"p"},"O(V + E)"),", where V is the number of nodes and E is the number of edges."),(0,i.kt)("p",null,"The space complexity of the algorithm is ",(0,i.kt)("inlineCode",{parentName:"p"},"O(V)"),"."),(0,i.kt)("h2",{id:"bfs-algorithm-applications"},"BFS Algorithm Applications"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"To build index by search index"),(0,i.kt)("li",{parentName:"ol"},"For GPS navigation"),(0,i.kt)("li",{parentName:"ol"},"Path finding algorithms"),(0,i.kt)("li",{parentName:"ol"},"In Ford-Fulkerson algorithm to find maximum flow in a network"),(0,i.kt)("li",{parentName:"ol"},"Cycle detection in an undirected graph")),(0,i.kt)("h2",{id:"code-implementation"},"Code Implementation"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// Breadth First Search in Go\n\npackage main\n\nimport "fmt"\n\nfunc BreadthFirstSearch(start, end, nodes int, edges [][]int) (isConnected bool, distance int) {\n    queue := make([]int, 0)\n    visited := make([]int, nodes)\n    visited[start] = 1\n    queue = append(queue, start)\n\n    for len(queue) > 0 {\n        v := queue[0]\n        queue = queue[1:]\n        for i := 0; i < len(edges[v]); i++ {\n            if visited[i] == 0 && edges[v][i] > 0 {\n                if i == end {\n                    return true, visited[v]\n                }\n                visited[i] = visited[v] + 1\n                queue = append(queue, i)\n            }\n        }\n    }\n\n    return false, 0\n}\n\nfunc main() {\n    fmt.Println(BreadthFirstSearch(0,\n        5,\n        6,\n        [][]int{\n            {0, 1, 1, 0, 0, 0},\n            {1, 0, 0, 1, 0, 1},\n            {1, 0, 0, 1, 0, 0},\n            {0, 1, 1, 0, 1, 0},\n            {0, 0, 0, 1, 0, 0},\n            {0, 1, 0, 0, 0, 0},\n        }))\n}\n\n')),(0,i.kt)("h2",{id:"reference"},"Reference"),(0,i.kt)("iframe",{width:"950",height:"534",src:"https://www.youtube.com/embed/oDqjPvD54Ss",title:"Breadth First Search Algorithm | Shortest Path | Graph Theory",frameborder:"0",allow:"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture",allowfullscreen:!0}))}u.isMDXComponent=!0},2568:function(e,t,r){t.Z=r.p+"assets/images/44Yjk0w80-clipboard-710a740bbafc737d9fcf34dc2a52d76b.png"},267:function(e,t,r){t.Z=r.p+"assets/images/4KLFdCD23-clipboard-e59d5b25acb4d5a82ac772ee4f67869b.png"},4673:function(e,t,r){t.Z=r.p+"assets/images/5VTw0YiCk-clipboard-23d71145de838d50f00c838360743186.png"},5001:function(e,t,r){t.Z=r.p+"assets/images/Etlf9uQUs-clipboard-1ff7c5a32baa38d46cb27b8f1eface3d.png"},118:function(e,t,r){t.Z=r.p+"assets/images/av1ps0C5b-clipboard-fa1c11b5316a8baceacb63aef3b68c6b.png"},5097:function(e,t,r){t.Z=r.p+"assets/images/x2yG8Pcd2-clipboard-17157c1935abe80e5c372d70ee09be55.png"}}]);