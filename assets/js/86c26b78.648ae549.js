"use strict";(self.webpackChunkme=self.webpackChunkme||[]).push([[2552],{3905:function(e,n,t){t.d(n,{Zo:function(){return c},kt:function(){return d}});var a=t(7294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=a.createContext({}),p=function(e){var n=a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},c=function(e){var n=p(e.components);return a.createElement(s.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),m=p(t),d=r,h=m["".concat(s,".").concat(d)]||m[d]||u[d]||i;return t?a.createElement(h,l(l({ref:n},c),{},{components:t})):a.createElement(h,l({ref:n},c))}));function d(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=m;var o={};for(var s in n)hasOwnProperty.call(n,s)&&(o[s]=n[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},8812:function(e,n,t){t.r(n),t.d(n,{assets:function(){return c},contentTitle:function(){return s},default:function(){return d},frontMatter:function(){return o},metadata:function(){return p},toc:function(){return u}});var a=t(7462),r=t(3366),i=(t(7294),t(3905)),l=["components"],o={},s="Cheat Sheet",p={unversionedId:"algorithm/golang/Cheat Sheet-Pk41f8xXe",id:"algorithm/golang/Cheat Sheet-Pk41f8xXe",title:"Cheat Sheet",description:"1. Basic Syntax",source:"@site/docs/algorithm/golang/20220703-Cheat Sheet-Pk41f8xXe.md",sourceDirName:"algorithm/golang",slug:"/algorithm/golang/Cheat Sheet-Pk41f8xXe",permalink:"/docs/algorithm/golang/Cheat Sheet-Pk41f8xXe",draft:!1,editUrl:"https://github.com/iamrahultanwar/me/tree/master/docs/algorithm/golang/20220703-Cheat Sheet-Pk41f8xXe.md",tags:[],version:"current",sidebarPosition:20220703,frontMatter:{},sidebar:"mainSidebar",previous:{title:"Insertion Sort",permalink:"/docs/algorithm/Insertion Sort-ksHw4JFHc"},next:{title:"CheatSheet",permalink:"/docs/algorithm/javascript/CheatSheet-KZS7tH1Dv"}},c={},u=[{value:"Credits",id:"credits",level:2},{value:"Go in a Nutshell",id:"go-in-a-nutshell",level:2},{value:"Hello World",id:"hello-world",level:2},{value:"Operators",id:"operators",level:2},{value:"Arithmetic",id:"arithmetic",level:3},{value:"Comparison",id:"comparison",level:3},{value:"Logical",id:"logical",level:3},{value:"Other",id:"other",level:3},{value:"Declarations",id:"declarations",level:2},{value:"Functions",id:"functions",level:2},{value:"Functions As Values And Closures",id:"functions-as-values-and-closures",level:3},{value:"Variadic Functions",id:"variadic-functions",level:3},{value:"Built-in Types",id:"built-in-types",level:2},{value:"Type Conversions",id:"type-conversions",level:2},{value:"Packages",id:"packages",level:2},{value:"Control structures",id:"control-structures",level:2},{value:"If",id:"if",level:3},{value:"Loops",id:"loops",level:3},{value:"Switch",id:"switch",level:3},{value:"Arrays, Slices, Ranges",id:"arrays-slices-ranges",level:2},{value:"Arrays",id:"arrays",level:3},{value:"Slices",id:"slices",level:3},{value:"Operations on Arrays and Slices",id:"operations-on-arrays-and-slices",level:3},{value:"Maps",id:"maps",level:2},{value:"Structs",id:"structs",level:2},{value:"Pointers",id:"pointers",level:2},{value:"Interfaces",id:"interfaces",level:2},{value:"Embedding",id:"embedding",level:2},{value:"Errors",id:"errors",level:2},{value:"Goroutines",id:"goroutines",level:2},{value:"Channels",id:"channels",level:2},{value:"Channel Axioms",id:"channel-axioms",level:3},{value:"Printing",id:"printing",level:2},{value:"Reflection",id:"reflection",level:2},{value:"Type Switch",id:"type-switch",level:3},{value:"Files Embedding",id:"files-embedding",level:2},{value:"HTTP Server",id:"http-server",level:2}],m={toc:u};function d(e){var n=e.components,t=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},m,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"cheat-sheet"},"Cheat Sheet"),(0,i.kt)("h1",{id:"go-cheat-sheet"},"Go Cheat Sheet"),(0,i.kt)("h1",{id:"index"},"Index"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#basic-syntax"},"Basic Syntax")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#operators"},"Operators"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#arithmetic"},"Arithmetic")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#comparison"},"Comparison")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#logical"},"Logical")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#other"},"Other")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#declarations"},"Declarations")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#functions"},"Functions"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#functions-as-values-and-closures"},"Functions as values and closures")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#variadic-functions"},"Variadic Functions")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#built-in-types"},"Built-in Types")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#type-conversions"},"Type Conversions")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#packages"},"Packages")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#control-structures"},"Control structures"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#if"},"If")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#loops"},"Loops")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#switch"},"Switch")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#arrays-slices-ranges"},"Arrays, Slices, Ranges"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#arrays"},"Arrays")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#slices"},"Slices")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#operations-on-arrays-and-slices"},"Operations on Arrays and Slices")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#maps"},"Maps")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#structs"},"Structs")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#pointers"},"Pointers")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#interfaces"},"Interfaces")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#embedding"},"Embedding")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#errors"},"Errors")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#concurrency"},"Concurrency"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#goroutines"},"Goroutines")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#channels"},"Channels")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#channel-axioms"},"Channel Axioms")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#printing"},"Printing")),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#reflection"},"Reflection"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#type-switch"},"Type Switch")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://github.com/a8m/reflect-examples"},"Examples")))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("a",{parentName:"li",href:"#snippets"},"Snippets"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#files-embedding"},"Files Embedding")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"#http-server"},"HTTP Server"))))),(0,i.kt)("h2",{id:"credits"},"Credits"),(0,i.kt)("p",null,"Most example code taken from ",(0,i.kt)("a",{parentName:"p",href:"http://tour.golang.org/"},"A Tour of Go"),", which is an excellent introduction to Go.\nIf you're new to Go, do that tour. Seriously."),(0,i.kt)("h2",{id:"go-in-a-nutshell"},"Go in a Nutshell"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Imperative language"),(0,i.kt)("li",{parentName:"ul"},"Statically typed"),(0,i.kt)("li",{parentName:"ul"},"Syntax tokens similar to C (but less parentheses and no semicolons) and the structure to Oberon-2"),(0,i.kt)("li",{parentName:"ul"},"Compiles to native code (no JVM)"),(0,i.kt)("li",{parentName:"ul"},"No classes, but structs with methods"),(0,i.kt)("li",{parentName:"ul"},"Interfaces"),(0,i.kt)("li",{parentName:"ul"},"No implementation inheritance. There's ",(0,i.kt)("a",{parentName:"li",href:"http://golang.org/doc/effective%5Fgo.html#embedding"},"type embedding"),", though."),(0,i.kt)("li",{parentName:"ul"},"Functions are first class citizens"),(0,i.kt)("li",{parentName:"ul"},"Functions can return multiple values"),(0,i.kt)("li",{parentName:"ul"},"Has closures"),(0,i.kt)("li",{parentName:"ul"},"Pointers, but not pointer arithmetic"),(0,i.kt)("li",{parentName:"ul"},"Built-in concurrency primitives: Goroutines and Channels")),(0,i.kt)("h1",{id:"basic-syntax"},"Basic Syntax"),(0,i.kt)("h2",{id:"hello-world"},"Hello World"),(0,i.kt)("p",null,"File ",(0,i.kt)("inlineCode",{parentName:"p"},"hello.go"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport "fmt"\n\nfunc main() {\n    fmt.Println("Hello Go")\n}\n')),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"$ go run hello.go")),(0,i.kt)("h2",{id:"operators"},"Operators"),(0,i.kt)("h3",{id:"arithmetic"},"Arithmetic"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Operator"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"+")),(0,i.kt)("td",{parentName:"tr",align:null},"addition")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"-")),(0,i.kt)("td",{parentName:"tr",align:null},"subtraction")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"*")),(0,i.kt)("td",{parentName:"tr",align:null},"multiplication")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"/")),(0,i.kt)("td",{parentName:"tr",align:null},"quotient")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"%")),(0,i.kt)("td",{parentName:"tr",align:null},"remainder")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"&")),(0,i.kt)("td",{parentName:"tr",align:null},"bitwise and")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\|")),(0,i.kt)("td",{parentName:"tr",align:null},"bitwise or")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"^")),(0,i.kt)("td",{parentName:"tr",align:null},"bitwise xor")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"&^")),(0,i.kt)("td",{parentName:"tr",align:null},"bit clear (and not)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"<<")),(0,i.kt)("td",{parentName:"tr",align:null},"left shift")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},">>")),(0,i.kt)("td",{parentName:"tr",align:null},"right shift")))),(0,i.kt)("h3",{id:"comparison"},"Comparison"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Operator"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"==")),(0,i.kt)("td",{parentName:"tr",align:null},"equal")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"!=")),(0,i.kt)("td",{parentName:"tr",align:null},"not equal")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"<")),(0,i.kt)("td",{parentName:"tr",align:null},"less than")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"<=")),(0,i.kt)("td",{parentName:"tr",align:null},"less than or equal")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},">")),(0,i.kt)("td",{parentName:"tr",align:null},"greater than")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},">=")),(0,i.kt)("td",{parentName:"tr",align:null},"greater than or equal")))),(0,i.kt)("h3",{id:"logical"},"Logical"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Operator"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"&&")),(0,i.kt)("td",{parentName:"tr",align:null},"logical and")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"\\|\\|")),(0,i.kt)("td",{parentName:"tr",align:null},"logical or")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"!")),(0,i.kt)("td",{parentName:"tr",align:null},"logical not")))),(0,i.kt)("h3",{id:"other"},"Other"),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Operator"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"&")),(0,i.kt)("td",{parentName:"tr",align:null},"address of / create pointer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"*")),(0,i.kt)("td",{parentName:"tr",align:null},"dereference pointer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"<-")),(0,i.kt)("td",{parentName:"tr",align:null},"send / receive operator (see 'Channels' below)")))),(0,i.kt)("h2",{id:"declarations"},"Declarations"),(0,i.kt)("p",null,"Type goes after identifier!"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'var foo int // declaration without initialization\nvar foo int = 42 // declaration with initialization\nvar foo, bar int = 42, 1302 // declare and init multiple vars at once\nvar foo = 42 // type omitted, will be inferred\nfoo := 42 // shorthand, only in func bodies, omit var keyword, type is always implicit\nconst constant = "This is a constant"\n\n// iota can be used for incrementing numbers, starting from 0\nconst (\n    _ = iota\n    a\n    b\n    c = 1 << iota\n    d\n)\n    fmt.Println(a, b) // 1 2 (0 is skipped)\n    fmt.Println(c, d) // 8 16 (2^3, 2^4)\n')),(0,i.kt)("h2",{id:"functions"},"Functions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// a simple function\nfunc functionName() {}\n\n// function with parameters (again, types go after identifiers)\nfunc functionName(param1 string, param2 int) {}\n\n// multiple parameters of the same type\nfunc functionName(param1, param2 int) {}\n\n// return type declaration\nfunc functionName() int {\n    return 42\n}\n\n// Can return multiple values at once\nfunc returnMulti() (int, string) {\n    return 42, "foobar"\n}\nvar x, str = returnMulti()\n\n// Return multiple named results simply by return\nfunc returnMulti2() (n int, s string) {\n    n = 42\n    s = "foobar"\n    // n and s will be returned\n    return\n}\nvar x, str = returnMulti2()\n\n')),(0,i.kt)("h3",{id:"functions-as-values-and-closures"},"Functions As Values And Closures"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"func main() {\n    // assign a function to a name\n    add := func(a, b int) int {\n        return a + b\n    }\n    // use the name to call the function\n    fmt.Println(add(3, 4))\n}\n\n// Closures, lexically scoped: Functions can access values that were\n// in scope when defining the function\nfunc scope() func() int{\n    outer_var := 2\n    foo := func() int { return outer_var}\n    return foo\n}\n\nfunc another_scope() func() int{\n    // won't compile because outer_var and foo not defined in this scope\n    outer_var = 444\n    return foo\n}\n\n\n// Closures\nfunc outer() (func() int, int) {\n    outer_var := 2\n    inner := func() int {\n        outer_var += 99 // outer_var from outer scope is mutated.\n        return outer_var\n    }\n    inner()\n    return inner, outer_var // return inner func and mutated outer_var 101\n}\n")),(0,i.kt)("h3",{id:"variadic-functions"},"Variadic Functions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"func main() {\n    fmt.Println(adder(1, 2, 3))     // 6\n    fmt.Println(adder(9, 9))    // 18\n\n    nums := []int{10, 20, 30}\n    fmt.Println(adder(nums...)) // 60\n}\n\n// By using ... before the type name of the last parameter you can indicate that it takes zero or more of those parameters.\n// The function is invoked like any other function except we can pass as many arguments as we want.\nfunc adder(args ...int) int {\n    total := 0\n    for _, v := range args { // Iterates over the arguments whatever the number.\n        total += v\n    }\n    return total\n}\n")),(0,i.kt)("h2",{id:"built-in-types"},"Built-in Types"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"bool\n\nstring\n\nint  int8  int16  int32  int64\nuint uint8 uint16 uint32 uint64 uintptr\n\nbyte // alias for uint8\n\nrune // alias for int32 ~= a character (Unicode code point) - very Viking\n\nfloat32 float64\n\ncomplex64 complex128\n")),(0,i.kt)("p",null,"All Go's predeclared identifiers are defined in the ",(0,i.kt)("a",{parentName:"p",href:"https://golang.org/pkg/builtin/"},"builtin")," package.  "),(0,i.kt)("h2",{id:"type-conversions"},"Type Conversions"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"var i int = 42\nvar f float64 = float64(i)\nvar u uint = uint(f)\n\n// alternative syntax\ni := 42\nf := float64(i)\nu := uint(f)\n")),(0,i.kt)("h2",{id:"packages"},"Packages"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Package declaration at top of every source file"),(0,i.kt)("li",{parentName:"ul"},"Executables are in package ",(0,i.kt)("inlineCode",{parentName:"li"},"main")),(0,i.kt)("li",{parentName:"ul"},"Convention: package name == last name of import path (import path ",(0,i.kt)("inlineCode",{parentName:"li"},"math/rand")," => package ",(0,i.kt)("inlineCode",{parentName:"li"},"rand"),")"),(0,i.kt)("li",{parentName:"ul"},"Upper case identifier: exported (visible from other packages)"),(0,i.kt)("li",{parentName:"ul"},"Lower case identifier: private (not visible from other packages)")),(0,i.kt)("h2",{id:"control-structures"},"Control structures"),(0,i.kt)("h3",{id:"if"},"If"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'func main() {\n    // Basic one\n    if x > 10 {\n        return x\n    } else if x == 10 {\n        return 10\n    } else {\n        return -x\n    }\n\n    // You can put one statement before the condition\n    if a := b + c; a < 42 {\n        return a\n    } else {\n        return a - 42\n    }\n\n    // Type assertion inside if\n    var val interface{} = "foo"\n    if str, ok := val.(string); ok {\n        fmt.Println(str)\n    }\n}\n')),(0,i.kt)("h3",{id:"loops"},"Loops"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"    // There's only `for`, no `while`, no `until`\n    for i := 1; i < 10; i++ {\n    }\n    for ; i < 10;  { // while - loop\n    }\n    for i < 10  { // you can omit semicolons if there is only a condition\n    }\n    for { // you can omit the condition ~ while (true)\n    }\n    \n    // use break/continue on current loop\n    // use break/continue with label on outer loop\nhere:\n    for i := 0; i < 2; i++ {\n        for j := i + 1; j < 3; j++ {\n            if i == 0 {\n                continue here\n            }\n            fmt.Println(j)\n            if j == 2 {\n                break\n            }\n        }\n    }\n\nthere:\n    for i := 0; i < 2; i++ {\n        for j := i + 1; j < 3; j++ {\n            if j == 1 {\n                continue\n            }\n            fmt.Println(j)\n            if j == 2 {\n                break there\n            }\n        }\n    }\n")),(0,i.kt)("h3",{id:"switch"},"Switch"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'    // switch statement\n    switch operatingSystem {\n    case "darwin":\n        fmt.Println("Mac OS Hipster")\n        // cases break automatically, no fallthrough by default\n    case "linux":\n        fmt.Println("Linux Geek")\n    default:\n        // Windows, BSD, ...\n        fmt.Println("Other")\n    }\n\n    // as with for and if, you can have an assignment statement before the switch value\n    switch os := runtime.GOOS; os {\n    case "darwin": ...\n    }\n\n    // you can also make comparisons in switch cases\n    number := 42\n    switch {\n        case number < 42:\n            fmt.Println("Smaller")\n        case number == 42:\n            fmt.Println("Equal")\n        case number > 42:\n            fmt.Println("Greater")\n    }\n\n    // cases can be presented in comma-separated lists\n    var char byte = \'?\'\n    switch char {\n        case \' \', \'?\', \'&\', \'=\', \'#\', \'+\', \'%\':\n            fmt.Println("Should escape")\n    }\n')),(0,i.kt)("h2",{id:"arrays-slices-ranges"},"Arrays, Slices, Ranges"),(0,i.kt)("h3",{id:"arrays"},"Arrays"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"var a [10]int // declare an int array with length 10. Array length is part of the type!\na[3] = 42     // set elements\ni := a[3]     // read elements\n\n// declare and initialize\nvar a = [2]int{1, 2}\na := [2]int{1, 2} //shorthand\na := [...]int{1, 2} // elipsis -> Compiler figures out array length\n")),(0,i.kt)("h3",{id:"slices"},"Slices"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'var a []int                              // declare a slice - similar to an array, but length is unspecified\nvar a = []int {1, 2, 3, 4}               // declare and initialize a slice (backed by the array given implicitly)\na := []int{1, 2, 3, 4}                   // shorthand\nchars := []string{0:"a", 2:"c", 1: "b"}  // ["a", "b", "c"]\n\nvar b = a[lo:hi]    // creates a slice (view of the array) from index lo to hi-1\nvar b = a[1:4]      // slice from index 1 to 3\nvar b = a[:3]       // missing low index implies 0\nvar b = a[3:]       // missing high index implies len(a)\na =  append(a,17,3) // append items to slice a\nc := append(a,b...) // concatenate slices a and b\n\n// create a slice with make\na = make([]byte, 5, 5)  // first arg length, second capacity\na = make([]byte, 5) // capacity is optional\n\n// create a slice from an array\nx := [3]string{"\u041b\u0430\u0439\u043a\u0430", "\u0411\u0435\u043b\u043a\u0430", "\u0421\u0442\u0440\u0435\u043b\u043a\u0430"}\ns := x[:] // a slice referencing the storage of x\n')),(0,i.kt)("h3",{id:"operations-on-arrays-and-slices"},"Operations on Arrays and Slices"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"len(a)")," gives you the length of an array/a slice. It's a built-in function, not a attribute/method on the array."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"// loop over an array/a slice\nfor i, e := range a {\n    // i is the index, e the element\n}\n\n// if you only need e:\nfor _, e := range a {\n    // e is the element\n}\n\n// ...and if you only need the index\nfor i := range a {\n}\n\n// In Go pre-1.4, you'll get a compiler error if you're not using i and e.\n// Go 1.4 introduced a variable-free form, so that you can do this\nfor range time.Tick(time.Second) {\n    // do it once a sec\n}\n\n")),(0,i.kt)("h2",{id:"maps"},"Maps"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'m := make(map[string]int)\nm["key"] = 42\nfmt.Println(m["key"])\n\ndelete(m, "key")\n\nelem, ok := m["key"] // test if key "key" is present and retrieve it, if so\n\n// map literal\nvar m = map[string]Vertex{\n    "Bell Labs": {40.68433, -74.39967},\n    "Google":    {37.42202, -122.08408},\n}\n\n// iterate over map content\nfor key, value := range m {\n}\n\n')),(0,i.kt)("h2",{id:"structs"},"Structs"),(0,i.kt)("p",null,"There are no classes, only structs. Structs can have methods."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"// A struct is a type. It's also a collection of fields\n\n// Declaration\ntype Vertex struct {\n    X, Y int\n}\n\n// Creating\nvar v = Vertex{1, 2}\nvar v = Vertex{X: 1, Y: 2} // Creates a struct by defining values with keys\nvar v = []Vertex{{1,2},{5,2},{5,5}} // Initialize a slice of structs\n\n// Accessing members\nv.X = 4\n\n// You can declare methods on structs. The struct you want to declare the\n// method on (the receiving type) comes between the the func keyword and\n// the method name. The struct is copied on each method call(!)\nfunc (v Vertex) Abs() float64 {\n    return math.Sqrt(v.X*v.X + v.Y*v.Y)\n}\n\n// Call method\nv.Abs()\n\n// For mutating methods, you need to use a pointer (see below) to the Struct\n// as the type. With this, the struct value is not copied for the method call.\nfunc (v *Vertex) add(n float64) {\n    v.X += n\n    v.Y += n\n}\n\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Anonymous structs:"),"\nCheaper and safer than using ",(0,i.kt)("inlineCode",{parentName:"p"},"map[string]interface{}"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"point := struct {\n    X, Y int\n}{1, 2}\n")),(0,i.kt)("h2",{id:"pointers"},"Pointers"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"p := Vertex{1, 2}  // p is a Vertex\nq := &p            // q is a pointer to a Vertex\nr := &Vertex{1, 2} // r is also a pointer to a Vertex\n\n// The type of a pointer to a Vertex is *Vertex\n\nvar s *Vertex = new(Vertex) // new creates a pointer to a new struct instance\n")),(0,i.kt)("h2",{id:"interfaces"},"Interfaces"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// interface declaration\ntype Awesomizer interface {\n    Awesomize() string\n}\n\n// types do *not* declare to implement interfaces\ntype Foo struct {}\n\n// instead, types implicitly satisfy an interface if they implement all required methods\nfunc (foo Foo) Awesomize() string {\n    return "Awesome!"\n}\n')),(0,i.kt)("h2",{id:"embedding"},"Embedding"),(0,i.kt)("p",null,"There is no subclassing in Go. Instead, there is interface and struct embedding."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// ReadWriter implementations must satisfy both Reader and Writer\ntype ReadWriter interface {\n    Reader\n    Writer\n}\n\n// Server exposes all the methods that Logger has\ntype Server struct {\n    Host string\n    Port int\n    *log.Logger\n}\n\n// initialize the embedded type the usual way\nserver := &Server{"localhost", 80, log.New(...)}\n\n// methods implemented on the embedded struct are passed through\nserver.Log(...) // calls server.Logger.Log(...)\n\n// the field name of the embedded type is its type name (in this case Logger)\nvar logger *log.Logger = server.Logger\n')),(0,i.kt)("h2",{id:"errors"},"Errors"),(0,i.kt)("p",null,"There is no exception handling. Instead, functions that might produce an error just declare an additional return value of type ",(0,i.kt)("a",{parentName:"p",href:"https://golang.org/pkg/builtin/#error"},(0,i.kt)("inlineCode",{parentName:"a"},"error")),". This is the ",(0,i.kt)("inlineCode",{parentName:"p"},"error")," interface:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"// The error built-in interface type is the conventional interface for representing an error condition,\n// with the nil value representing no error.\ntype error interface {\n    Error() string\n}\n")),(0,i.kt)("p",null,"Here's an example:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'func sqrt(x float64) (float64, error) {\n    if x < 0 {\n        return 0, errors.New("negative value")\n    }\n    return math.Sqrt(x), nil\n}\n\nfunc main() {\n    val, err := sqrt(-1)\n    if err != nil {\n        // handle error\n        fmt.Println(err) // negative value\n        return\n    }\n    // All is good, use `val`.\n    fmt.Println(val)\n}\n')),(0,i.kt)("h1",{id:"concurrency"},"Concurrency"),(0,i.kt)("h2",{id:"goroutines"},"Goroutines"),(0,i.kt)("p",null,"Goroutines are lightweight threads (managed by Go, not OS threads). ",(0,i.kt)("inlineCode",{parentName:"p"},"go f(a, b)")," starts a new goroutine which runs ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," (given ",(0,i.kt)("inlineCode",{parentName:"p"},"f")," is a function)."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'// just a function (which can be later started as a goroutine)\nfunc doStuff(s string) {\n}\n\nfunc main() {\n    // using a named function in a goroutine\n    go doStuff("foobar")\n\n    // using an anonymous inner function in a goroutine\n    go func (x int) {\n        // function body goes here\n    }(42)\n}\n')),(0,i.kt)("h2",{id:"channels"},"Channels"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'ch := make(chan int) // create a channel of type int\nch <- 42             // Send a value to the channel ch.\nv := <-ch            // Receive a value from ch\n\n// Non-buffered channels block. Read blocks when no value is available, write blocks until there is a read.\n\n// Create a buffered channel. Writing to a buffered channels does not block if less than <buffer size> unread values have been written.\nch := make(chan int, 100)\n\nclose(ch) // closes the channel (only sender should close)\n\n// read from channel and test if it has been closed\nv, ok := <-ch\n\n// if ok is false, channel has been closed\n\n// Read from channel until it is closed\nfor i := range ch {\n    fmt.Println(i)\n}\n\n// select blocks on multiple channel operations, if one unblocks, the corresponding case is executed\nfunc doStuff(channelOut, channelIn chan int) {\n    select {\n    case channelOut <- 42:\n        fmt.Println("We could write to channelOut!")\n    case x := <- channelIn:\n        fmt.Println("We could read from channelIn")\n    case <-time.After(time.Second * 1):\n        fmt.Println("timeout")\n    }\n}\n')),(0,i.kt)("h3",{id:"channel-axioms"},"Channel Axioms"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A send to a nil channel blocks forever"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-go"},'var c chan string\nc <- "Hello, World!"\n// fatal error: all goroutines are asleep - deadlock!\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A receive from a nil channel blocks forever"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-go"},"var c chan string\nfmt.Println(<-c)\n// fatal error: all goroutines are asleep - deadlock!\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A send to a closed channel panics"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-go"},'var c = make(chan string, 1)\nc <- "Hello, World!"\nclose(c)\nc <- "Hello, Panic!"\n// panic: send on closed channel\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A receive from a closed channel returns the zero value immediately"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre",className:"language-go"},'var c = make(chan int, 2)\nc <- 1\nc <- 2\nclose(c)\nfor i := 0; i < 3; i++ {\n    fmt.Printf("%d ", <-c)\n}\n// 1 2 0\n')))),(0,i.kt)("h2",{id:"printing"},"Printing"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'fmt.Println("Hello, \u4f60\u597d, \u0928\u092e\u0938\u094d\u0924\u0947, \u041f\u0440\u0438\u0432\u0435\u0442, \u13a3\u13cf\u13f2") // basic print, plus newline\np := struct { X, Y int }{ 17, 2 }\nfmt.Println( "My point:", p, "x coord=", p.X ) // print structs, ints, etc\ns := fmt.Sprintln( "My point:", p, "x coord=", p.X ) // print to string variable\n\nfmt.Printf("%d hex:%x bin:%b fp:%f sci:%e",17,17,17,17.0,17.0) // c-ish format\ns2 := fmt.Sprintf( "%d %f", 17, 17.0 ) // formatted print to string variable\n\nhellomsg := `\n "Hello" in Chinese is \u4f60\u597d (\'Ni Hao\')\n "Hello" in Hindi is \u0928\u092e\u0938\u094d\u0924\u0947 (\'Namaste\')\n` // multi-line string literal, using back-tick at beginning and end\n')),(0,i.kt)("h2",{id:"reflection"},"Reflection"),(0,i.kt)("h3",{id:"type-switch"},"Type Switch"),(0,i.kt)("p",null,"A type switch is like a regular switch statement, but the cases in a type switch specify types (not values) which are compared against the type of the value held by the given interface value."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'func do(i interface{}) {\n    switch v := i.(type) {\n    case int:\n        fmt.Printf("Twice %v is %v\\n", v, v*2)\n    case string:\n        fmt.Printf("%q is %v bytes long\\n", v, len(v))\n    default:\n        fmt.Printf("I don\'t know about type %T!\\n", v)\n    }\n}\n\nfunc main() {\n    do(21)\n    do("hello")\n    do(true)\n}\n')),(0,i.kt)("h1",{id:"snippets"},"Snippets"),(0,i.kt)("h2",{id:"files-embedding"},"Files Embedding"),(0,i.kt)("p",null,"Go programs can embed static files using the ",(0,i.kt)("inlineCode",{parentName:"p"},'"embed"')," package as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "embed"\n    "log"\n    "net/http"\n)\n\n// content holds the static content (2 files) for the web server.\n//go:embed a.txt b.txt\nvar content embed.FS\n\nfunc main() {\n    http.Handle("/", http.FileServer(http.FS(content)))\n    log.Fatal(http.ListenAndServe(":8080", nil))\n}\n')),(0,i.kt)("p",null,(0,i.kt)("a",{parentName:"p",href:"https://play.golang.org/p/pwWxdrQSrYv"},"Full Playground Example")),(0,i.kt)("h2",{id:"http-server"},"HTTP Server"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},'package main\n\nimport (\n    "fmt"\n    "net/http"\n)\n\n// define a type for the response\ntype Hello struct{}\n\n// let that type implement the ServeHTTP method (defined in interface http.Handler)\nfunc (h Hello) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n    fmt.Fprint(w, "Hello!")\n}\n\nfunc main() {\n    var h Hello\n    http.ListenAndServe("localhost:4000", h)\n}\n\n// Here\'s the method signature of http.ServeHTTP:\n// type Handler interface {\n//     ServeHTTP(w http.ResponseWriter, r *http.Request)\n// }\n')))}d.isMDXComponent=!0}}]);